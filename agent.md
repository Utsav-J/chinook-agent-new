# Agent Developer Documentation

This document provides technical details for developers integrating the Chinook Data Speech Agent into applications or exposing it via APIs.

## 1. Agent Overview

The **Chinook Data Speech Agent** (internal name: `sql_agent`) is a stateful, conversational AI agent designed to query a SQLite database. It uses **LangGraph** for workflow management and **Google Gemini 2.5 Flash** as the underlying LLM.

### Core Capabilities
- **Natural Language to SQL**: Converts user questions into valid SQL `SELECT` queries.
- **Identity Verification**: Enforces a "login" flow where users must identify themselves against the `Customer` table before querying data.
- **Context Awareness**: Maintains conversation history via thread-based persistence.

---

## 2. Authentication & Guardrails

The agent implements a strict middleware gatekeeper called `require_valid_name`.

### The "Valid Name" Gate
Before the agent allows any database querying, the user **must** provide a name that exists in the Chinook `Customer` table.

1. **Initial State**: `has_valid_name = False`
2. **Behavior**:
   - The agent ignores all data queries.
   - It forces the system prompt to: *"You must first collect the user's first and last name..."*
   - The only allowed tool is `update_user_name`.
3. **Transition**:
   - User provides name → Agent calls `update_user_name`.
   - If name exists in DB → `has_valid_name = True`.
   - If name is invalid → State remains `False`, and agent asks again.

**Developer Note:** API consumers should handle the initial interaction gracefully, knowing the agent will always start by asking "Who are you?" (or similar) until authenticated.

---

## 3. Tools Available to Agent

The agent has access to two specific tools:

### `execute_sql`
- **Description**: Executes a read-only SQL query on the connected Chinook database.
- **Arguments**: `query` (str)
- **Safety**:
    - Restricted to `SELECT` statements via system prompt instructions (though raw execution should still be sandboxed in production).
    - Errors are caught and returned to the agent to allow for self-correction.

### `update_user_name`
- **Description**: Updates the Runtime Context with the user's validated identity.
- **Arguments**: `new_first_name` (str), `new_last_name` (str)
- **Output**: Returns a `ToolMessage` indicating success or failure (i.e., if the customer was found).
- **Side Effect**: Updates the `user_first_name`, `user_last_name`, and `has_valid_name` flags in the runtime state.

---

## 4. State & Context Management

The agent uses a dual-state mechanism:

### 1. Checkpointer (`InMemorySaver`)
- **Purpose**: Persists the conversation history (messages).
- **Key**: `thread_id` (passed in `config`).
- **Persistence**: In this implementation, it is **in-memory**. Usage across server restarts requires an external persistence layer (e.g., Postgres, Redis) if not using the default `InMemorySaver`.

### 2. Runtime Context (`RuntimeContext`)
This dataclass is injected into every agent step but is **not** persisted by the basic checkpointer. The API layer (FastAPI) or client must manage this context or re-inject current values.

```python
@dataclass
class RuntimeContext:
    db: SQLDatabase           # Connection to Chinook.db
    user_first_name: str      # Identified user
    user_last_name: str       # Identified user
    has_valid_name: bool      # Gatekeeper flag
```

---

## 5. System Prompt Strategy

The system prompt is **dynamic**, generated by `dynamic_system_prompt`.

- **Injects Schema**: Automatically inserts a list of `available_tables` into the prompt.
- **Injects User Info**: Once identified, the `user_first_name` is inserted into the prompt to allow the LLM to personalize responses (e.g., "Here are your invoices, Frank").

---

## 6. Integration Interface

When calling the agent (e.g., via `agent.stream` or `agent.invoke`), you must provide three key components:

### A. Input Payload
```json
{
  "messages": [
    { "role": "user", "content": "How much did I spend last month?" }
  ]
}
```

### B. Configuration (Thread ID)
Used to thread messages together.
```python
config = {"configurable": {"thread_id": "unique-session-id-123"}}
```

### C. Context Injection
You must initialize the `RuntimeContext` for every invocation.

```python
context = RuntimeContext(
    db=db_instance,
    user_first_name="",  # Or retrieved from session storage
    user_last_name="",   # Or retrieved from session storage
    has_valid_name=False # Or retrieved from session storage
)
```

---

## 7. Example Invocation (Python)

```python
from agent import agent, RuntimeContext, get_db

# 1. Setup
db = get_db()
thread_id = "session_user_55"

# 2. Initial Context (User Unverified)
ctx = RuntimeContext(db=db, user_first_name="", user_last_name="", has_valid_name=False)

# 3. Stream Response
inputs = {"messages": [{"role": "user", "content": "Hello, I am Frank Harris"}]}

for step in agent.stream(inputs, config={"configurable": {"thread_id": thread_id}}, context=ctx):
    # Handle stream events...
    pass
```
